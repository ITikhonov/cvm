Opcodes from http://www.colorforth.com/inst.htm except no
'unext' and '!p'. Opcode '+*' replaced with '*'.

=opcodes
-opcodes='; ex jump call unext next if -if @p @+ @b @ !p !+ !b ! * 2* 2/ - + and or drop dup pop over a . push b! a!'.split()
-opcodes=dict(zip(opcodes,range(len(opcodes))))
-opcodes['exit']=0x99
-opcodes['char']=0x98
-opcodes['print']=0x97
-opcodes['memsize']=0x96

Each non-empty line of input contains one definition. First word is a name
of what will be defined, the rest is a definition.

=input
-from sys import argv
-for l in open(argv[1]):
-	l=l.strip()
-	if not l: continue
-	parseone(l)

We put everythin into wordset represented by global dict ws.

=parser
-ws={}
-def parseone(l):
-	w=l.split()
-	ws[w[0]]=w[1:]

We join all definitions into one list noting where each starting.

In each definition opcode words replaced with numbers. Numberic literals are replaced by @p instruction and number.

In the end replace all names with offsets

Also words starting with ':' are labels we don't compile them, but remember address. When encountered later
we store offset.

=compiler
-from struct import pack
-def makeint(i):
-	return [ord(x) for x in pack('I',i)]
-def op(x):
-	try: return [opcodes[x]]
-	except KeyError:
-		try: return [0x08]+makeint(int(x,16))
-		except ValueError: return [0x03,x,0,0,0]

-def compile():
-	dbg={}
-	o={}
-	c=[0,0,0,0,
-	   0x10,0,0,0,
-	   0x30,0,0,0,
-	   0,0,0,0,
-	   0,0,0,0,
-	   1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,
-	   1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8]
-	for w,d in ws.items():
-		l=dict.fromkeys([x[1:] for x in d if x.startswith(':')])
-		o[w]=len(c)
-		for x in d:
-			if x.startswith(':'): o[w+x]=len(c)
-			elif x in l: c.extend([w+':'+x,None,None,None])
-			else:
-				dbg[len(c)]=w+' '+x
-				c.extend(op(x))
-		dbg[len(c)]=''+w+'/'
-		c.append(0x00)
-	o['data']=len(c)
-	c.extend([0x08]+makeint(len(c)+6)+[0x00])
-	c[0]=o['main']
-	print o
-	for i in range(len(c)):
-		x=c[i]
-		if type(x) is str:
-			off=makeint(o[x])
-			c[i:i+4]=off
-	return c,dbg


Then we dump everything into file as 16-bit integers

=store
-from array import array

-def store(l,n):
-	u=[x for x in l if type(x) is not int]
-	if u:
-		print 'unresolved',u
-		exit(1)
-	array('B',l).tofile(open(n,'w'))

=debug
-def debug(d,n):
-	m=max(d)
-	idx=array('I',[m+1])
-	ss=array('B')
-	for i in range(m):
-		if i in d:
-			idx.append(len(ss)+m*4+4)
-			ss.fromstring(d[i])
-			ss.append(0)
-		else: idx.append(0)
-	f=open(n,'w')
-	idx.tofile(f)
-	ss.tofile(f)
-	f.close()

=>f.py
>opcodes
>parser
>compiler
>input
>store
>debug
-l,d=compile()
-store(l,argv[2])
-debug(d,argv[3])



